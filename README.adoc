:spring_version: current
:spring_boot_version: 2.1.4.RELEASE
:toc:
:icons: font
:source-highlighter: prettify
:project_id: scs-solace
This guide walks you through the process of creating event-driven microservices using Spring Cloud Streams with a partner maintained binder

== What you'll build

This Getting Started Guide will show you how to create event-driven microservices using Spring Cloud Streams with the Solace PubSub+ Binder. You will create a Source (sending app), a Sink (receiving app), and a Processor (combination of a source & a sink). The apps will exchange events using a shared PubSub+ Event Broker.

== What you'll need

* About 15-30 minutes
* Be somewhat familiar with Java 
* A favorite text editor or IDE
** link:/guides/gs/sts[Spring Tool Suite (STS) ]
** link:/guides/gs/intellij-idea/[IntelliJ IDEA]
* Maven 3.5.3 or higher (ensure it's on your PATH) https://maven.apache.org/install.html[Install Steps Here]
* JDK 1.8+ (ensure your PATH & JAVA_HOME are updated as needed)
* A PubSub+ Event Broker (instructions below)

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/how_to_complete_this_guide.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-sts.adoc[]

[[scratch]]
== Get a Solace PubSub+ Event Broker

=== Option 1: Use Solace Cloud
Start up a FREE service in Solace Cloud. 
https://console.solace.cloud/login/new-account[Solace Cloud Sign-up]

The messaging connectivity information is found in the service details on the connect tab (shown below). You will need:
- SMF Host
- Message VPN
- Client Username
- Client Password

image::https://solace.com/samples/solace-samples-spring/assets/images/connectivity-info.png[Solace Cloud Connect Info]

=== Option 2: Use Docker
If you have docker installed a second option is to setup a local Solace PubSub+ instance! 
https://solace.com/software/getting-started/[Start up PubSub+ in Docker]

[[initial]]
== Install the data model
In order to compile/run the actual microservices the data model must first be installed to your local maven repo. 

----
cd initial/spring-samples-datamodel
mvn clean install
----

== Create a Spring Cloud Stream Sink

=== Analyze the Maven Dependencies
Using your favorite text editor open the initial/cloud-streams-sink/pom.xml file

----
cd initial/cloud-streams-sink
vim pom.xml
----

This file defines the dependencies needed for our Sink app to build & run, but they are also the same for our Source and Processor apps.
Note that the app is actually a Spring Boot Application & is based off the spring-boot-starter-parent.
----
    <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>2.1.4.RELEASE</version>
            <relativePath /> 
    </parent>
----


Also note that the dependency below is what enables us to use the Solace PubSub+ Binder.
----
    <dependency>
            <groupId>com.solace.spring.cloud</groupId>
            <artifactId>spring-cloud-starter-stream-solace</artifactId>
            <version>1.1.0</version>
    </dependency>
----

=== Code the Sink!
Open the TemperatureSink.java file in the `initial/cloud-streams-sink` project.
This class shows how simple it is to write a Spring Cloud Streams app that consumes events from PubSub+.

Copy the code below in place of the `//TODO - INSERT CODE HERE` comment.

A few things to take note of:

* The @SpringBootApplication annotation enables auto-configuration and component scanning
* The @EnableBinding(Sink.class) annotation tells us that we are creating a Spring Cloud Streams Sink application and enables the Input channel on the Sink binding interface. This Sink's input channel will connect to our messaging system at run time.
* The @StreamListener annotation defines which method should be invoked when an event is received on our Sink.INPUT channel.

----
@SpringBootApplication
@EnableBinding(Sink.class)
public class TemperatureSink {
	private static final Logger log = LoggerFactory.getLogger(TemperatureSink.class);

	public static void main(String[] args) {
		SpringApplication.run(TemperatureSink.class, args);
	}

	// We define an INPUT to receive from
	@StreamListener(Sink.INPUT)
	public void sink(SensorReading reading) {
		log.info("Received: " + reading);
	}
}
----

=== Configure the Sink
Next let's take a look at the application.yml file. Note that an application.properties file could be used instead.
Open the application.yml file in the `initial/cloud-streams-sink` project.

A few things to take note of:

* The spring.cloud.stream.bindings.input maps to the Sink.INPUT channel for our application.
* Because a `group` is specified we are following the Spring Cloud Streams `Consumer Group` pattern; if a group was not specified the app would be using the Publish-Subscribe pattern.
* Spring Cloud Streams will use the `solaceBroker` binder since it's the only one present; if multiple binders are present you can specify the binder on each binding.
* Change your *host*, *msgVpn*, *clientUsername* & *clientPassword* to match your Solace Messaging Service. The host should be your `SMF URI`.
* Notice the spring.cloud.steams.solace.bindings is where Solace specific configurations can be set; here we see an example where we are telling our queue to subscribe to the `sensor/temperature/>` topic. The `>` sign is a wildcard that allows us to receive any events sent to any topic that starts with `sensor/temperature/` We will be using it to receive events on `sensor/temperature/celsius` and `sensor/temperature/fahrenheit` topics.

---- 
spring:
  cloud:
    stream:
      bindings:
        input:
          destination: TEMPS.Q
          #The presence of "group" tells the binder to follow the "consumer group" pattern
          group: SINK
      binders:
        solaceBroker:
          type: solace
          environment:
            solace:
              java:
                host: tcp://localhost:55555
                msgVpn: default
                clientUsername: default
                clientPassword: default
      solace:
        bindings:
          input:
            consumer:
              queueAdditionalSubscriptions: sensor/temperature/>
----

=== Sink: Run the app
Now it's time to run the app.
Run from the command line using maven like seen below

----
mvn spring-boot:run
----

You should see the application start; you will know it's started when the console has a line that contains `Started TemperatureSink in`
Leave the app running for the remainder of the tutorial & don't worry that no events are being received yet.

== Create a Spring Cloud Stream Source

=== Code the Source!
Open a new console/terminal if needed. 
Open the FahrenheitTempSource.java file in the `initial/cloud-streams-source` project. 
This class shows how simple it is to write a Spring Cloud Streams app that sends events to PubSub+.
The class is simulating an event source that emits a temperature, in Fahrenheit, every 5 seconds. 

Copy the code below in place of the `//TODO - INSERT CODE HERE` comment.

A few things to take note of: 

* As before the @SpringBootApplication annotation enables auto-configuration and component scanning
* The @EnableBinding(Source.class) annotation tells us that we are creating a Spring Cloud Streams Source application and enables the Output channel on the Source binding interface. This Source's output channel will connect to our messaging system at run time.
* The @InboundChannelAdapter annotation defines which method will be using the Source.OUTPUT channel. It is also enabling us to send a SensorReading event every 5 seconds. 

---- 
@SpringBootApplication
@EnableBinding(Source.class)
public class FahrenheitTempSource {
    private static final Logger log = LoggerFactory.getLogger(FahrenheitTempSource.class);

    private static final UUID sensorIdentifier = UUID.randomUUID();
    private static final Random random = new Random(System.currentTimeMillis());
    private static final int RANDOM_MULTIPLIER = 100;
    

        public static void main(String[] args) {
                SpringApplication.run(FahrenheitTempSource.class, args);
        }

    @InboundChannelAdapter(channel = Source.OUTPUT, poller = @Poller(fixedRate = "5000"))
    public SensorReading emitSensorReading() {
        double temperature = random.nextDouble() * RANDOM_MULTIPLIER;

        SensorReading reading = new SensorReading();
        reading.setSensorID(sensorIdentifier.toString());
        reading.setTemperature(temperature);
        reading.setBaseUnit(BaseUnit.FAHRENHEIT);
        
        log.info("Emitting " + reading);

        return reading;
    }
----

=== Configure the Source!
Next let's take a look at the application.yml file. As stated earlier, an application.properties file could be used instead. 
Open the application.yml file in the `initial/cloud-streams-source` project.

A few things to take note of: 

* The spring.cloud.stream.bindings.output maps to the Source.OUTPUT channel for our application; in this example we are sending to the `sensor/temperature/fahrenheit` topic. 
* Spring Cloud Streams will use the `solaceBroker` binder since it's the only one present; if multiple binders are present you can specify the binder on each binding. 
* Change your *host*, *msgVpn*, *clientUsername* & *clientPassword* to match your Solace Messaging Service. The host should be your `SMF URI`.

---- 
spring:
  cloud:
    stream:
      bindings:
        output:
          destination: sensor/temperature/fahrenheit
          binder: solaceBroker
      binders:
        solaceBroker:
          type: solace
          environment:
            solace:
              java:
                host: tcp://localhost:55555
                msgVpn: default
                clientUsername: default
                clientPassword: default
----

=== Source:Run the app
Now it's time to run the app.
Run from the command line using maven like seen below

----
mvn spring-boot:run
----

You should see the application start; you will know it's started when the console has a line that contains `Started FahrenheitTempSource in` 
After starting you should see the Source app emitting an event every 5 seconds. 
Note that if you look back at your Sink app that was deployed previously you should now see it receiving the events that are being emitted. 

At this point you have now implemented a sending & receiving app using Spring Cloud Streams and PubSub+ !!
Leave the app running for the remainder of the tutorial.

== Create a Spring Cloud Stream Processor 

=== Code the Processor!
Open a new console/terminal if needed.
Open the ConvertFtoCProcessor.java file in the `initial/cloud-streams-processor` project.
This class shows how simple it is to write a Spring Cloud Streams app that receives, processesses & sends to PubSub+.
The class is a processor which receives SensorReadings in Fahrenheit from one topic, converts them to Celsius and publishes the updated SensorReadings to a Celsius topic

Copy the code below in place of the `//TODO - INSERT CODE HERE` comment.

A few things to take note of:

* As before the @SpringBootApplication annotation enables auto-configuration and component scanning
* The @EnableBinding(Processor.class) annotation tells us that we are creating a Spring Cloud Streams Processor application and enables the Input & Output channels on the Processor binding interface. This Prcoessor's input & output channels will be bound to our messaging system at run time.
* The @StreamListener annotation defines which method should be invoked when an event is received on our Processor.INPUT channel.
* The @SendTo annotation defines that returned objects from the method should be sent to the Processor.OUTPUT channel.

---- 
@SpringBootApplication
@EnableBinding(Processor.class)
public class ConvertFtoCProcessor {

	private static final Logger log = LoggerFactory.getLogger(ConvertFtoCProcessor.class);

	public static void main(String[] args) {
		SpringApplication.run(ConvertFtoCProcessor.class, args);
	}

	@StreamListener(Processor.INPUT)
	@SendTo(Processor.OUTPUT)
	public SensorReading handle(SensorReading reading) {

		log.info("Received: " + reading);

		double temperatureCelsius = (reading.getTemperature().doubleValue() - 32) * 5 / 9;
                reading.setTemperature(temperatureCelsius);
                reading.setBaseUnit(SensorReading.BaseUnit.CELSIUS);

		log.info("Sending: " + reading);
		return reading;
	}
}
----

=== Configure the Processor!
Next let's take a look at the application.yml file. As stated earlier, an application.properties file could be used instead.
Open the application.yml file in the `initial/cloud-streams-processor` project.

A few things to take note of:

* The spring.cloud.stream.bindings now includes both an `input` and an `output` binding. These maps to our Processor.INPUT & Processor.OUTPUT channels respectively; note that our output destination will be sending to the `sensor/temperature/celsius` topic.
* Spring Cloud Streams will use the `solaceBroker` binder since it's the only one present; if multiple binders are present you can specify the binder on each binding.
* Change your *host*, *msgVpn*, *clientUsername* & *clientPassword* to match your Solace Messaging Service. The host should be your `SMF URI`.
* Notice the spring.cloud.steams.solace.bindings is where Solace specific configurations can be set; here we see an example where we are telling our input bindings queue to subscribe to the `sensor/temperature/fahrenheit` topic.

---- 
spring:
  cloud:
    stream:
      default-binder: solaceBroker
      bindings:
        input:
          destination: TEMPS.Q
          group: PROCESSOR
        output:
          destination: sensor/temperature/celsius
      binders:
        solaceBroker:
          type: solace
          environment:
            solace:
              java:
                host: tcp://localhost:55555
                msgVpn: default
                clientUsername: default
                clientPassword: default
                connectRetries: -1
                reconnectRetries: -1
      solace:
        bindings:
          input:
            consumer:
              queueAdditionalSubscriptions: sensor/temperature/fahrenheit
----

=== Processor:Run the app
Now it's time to run the app.
Run from the command line using maven like seen below

----
mvn spring-boot:run
----

You should see the application start; you will know it's started when the console has a line that contains `Started ConvertFtoCProcessor in`
After starting you should see the Processor app start to process the fahrenheit events sent by the Source that is still running from before.

Note that if you look back at your Sink app you should now see it receiving both Fahrenheit & Celsius events. This is because it is subscribed the `sensor/temperature/>` topic subscription where `>` is a wildcard. 
Fahrenheit events are being received from the initial Source app from the `sensor/temperature/fahrenheit` topic and Celsius events are being received from the Processor app from the `sensor/temperature/celsius` topic.

== Summary

Woohoo! You built a source, sink and processor microservice using Spring Cloud Streams and exchanged events between them over a shared event broker! 

Hopefully you found that Spring Cloud Stream makes it super simple to develop event-driven microservices! Note that you did not have to learn any messaging APIs in order to use Spring Cloud Streams. It allowed you to create an entire event creation, processing and receiving chain without having to use Messaging APIs allowing you to focus on your business goals.

== See Also

You can learn more in the https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/[Spring Cloud Stream Reference Guide]
Questions about Solace PubSub+ in the  https://solace.community[Solace Developer Community]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/footer.adoc[]
