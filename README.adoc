---
tags: []
projects: []
---
:spring_version: 5.0.0.RC3
:spring_boot_version: 2.0.0.BUILD-SNAPSHOT
:SpringApplication: http://docs.spring.io/spring-boot/docs/{spring_boot_version}/api/org/springframework/boot/SpringApplication.html
:toc:
:icons: font
:source-highlighter: prettify
:project_id: draft-gs-template

This guide walks you through the process of creating a "Hello, Spring!" RESTful web service with Reactive Spring (new as of version 5) and then consumes that service with a WebClient.

What is the reactive stack that supports this guide? Spring WebFlux is the web module for Reactive Spring and lives in the new `spring-web-reactive` module next to the existing (and popular!) Spring Web MVC that lives in the `spring-webmvc` module. The two modules share many algorithms and mechanisms but cannot actually share any code. This is because Reactive Spring runs on a Reactive Streams HTTP adapter layer that’s fully non-blocking and reactive all the way down to the HTTP runtime. So while Spring MVC is built for and runs on Servlet containers, Spring WebFlux runs also on non-Servlet runtimes, such as on Netty and Undertow. This application runs on Netty.

== What you'll build

You’ll build a RESTful web service with Reactive Spring and a WebClient consumer of that service. You'll be able to see output in both System.out and at:

[source]
http://localhost:8080/greeting

== What you'll need

:java_version: 1.8
include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/prereq_editor_jdk_buildtools.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/how_to_complete_this_guide.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-gradle.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-maven.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/hide-show-sts.adoc[]

[[initial]]
== Create a WebFlux Handler

Create a new WebFlux handler class for your Reactive Spring application:

`src/main/java/hello/GreetingHandler.java`
[source,java]
----
include::complete/src/main/java/hello/GreetingHandler.java[]
----

This simplest possible reactive class always returns "Hello, Spring!" It could return many other things, including a stream of items from a database, a stream of items that were generated by calculations, and so on. Note the reactive code: a `Mono` object that holds a `ServerResponse` body.

== Create a Router

In this application, we expose our RESTful resource through a router class:

`src/main/java/hello/GreetingRouter.java`
[source,java]
----
include::complete/src/main/java/hello/GreetingRouter.java[]
----

The router listens for traffic on the `/hello` path and returns the value provided by our reactive handler class.

== Create a WebClient

To consume our RESTful resource, we create a WebClient:

`src/main/java/hello/GreetingWebClient.java`
[source,java]
----
include::complete/src/main/java/hello/GreetingWebClient.java[]
----

Note that the WebClient also uses reactive features, in the form a Mono to hold the content of the URI we specify and a function (in the `getResult` method) to turn that content into a string. If we had different requirements, we might turn it into something other than a string. Since we're going to put the result into System.out, a string will do here.

== Make the application executable

Although it is possible to package this service as a traditional link:/understanding/WAR[WAR] file for deployment to an external application server, the simpler approach demonstrated below creates a standalone application. You package everything in a single, executable JAR file, driven by a good old Java `main()` method. Along the way, you use Reactive Spring's support for embedding the Netty server as the HTTP runtime, instead of deploying to an external instance.


`src/main/java/hello/Application.java`
[source,java]
----
include::complete/src/main/java/hello/Application.java[]
----

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/spring-boot-application.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/build_an_executable_jar_subhead.adoc[]

include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/build_an_executable_jar_with_both.adoc[]


Logging output is displayed. The service should be up and running within a few seconds.

Once the service has started, you'll see a line that reads:

`>> result = Hello, Spring!`

That line comes from the reactive content being consumed by the WebClient. Naturally, you'll find something more interesting to do with your output than put it in System.out.

== Test the application

Now that the application is running, you can test it. To start with, you can open a browser and go to `http://localhost:8080/hello` and see, "Hello, Spring!" For this guide, we also created a test class to get you started on testing with the WebTestClient class.

`src/test/java/hello/GreetingRouterTest.java`
[source,java]
----
include::complete/src/test/java/hello/GreetingRouterTest.java[]
----

== Summary

Congratulations! You've just developed a Reactive Spring application that includes a WebClient to consume a RESTful service!




include::https://raw.githubusercontent.com/spring-guides/getting-started-macros/master/footer.adoc[]
